<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dirk: Worms Edition Final</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Modern Tech Font -->
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #051005, #020502); /* Diep donkergroen/zwart */
            touch-action: none; /* Cruciaal voor iPad: blokkeert standaard gestures */
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            color: #e2e8f0;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            box-sizing: border-box;
            z-index: 10;
        }
        .hud-panel {
            background: rgba(20, 35, 25, 0.85);
            padding: 16px 24px;
            border-radius: 20px;
            border: 1px solid rgba(74, 222, 128, 0.15);
            backdrop-filter: blur(12px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 220px;
        }
        .hud-text {
            color: #86efac;
            text-shadow: 0 0 15px rgba(74, 222, 128, 0.2);
            font-weight: 700;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            font-size: 1.25rem;
        }
        .sub-text {
            color: #94a3b8;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 4px;
        }
        
        /* Screens */
        #start-screen, #game-over-screen, #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(3, 8, 3, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
        }
        #game-over-screen, #victory-screen {
            display: none;
        }

        .card {
            background: rgba(25, 40, 30, 0.6);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 32px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
        }

        button {
            background: linear-gradient(135deg, #16a34a, #15803d);
            color: white;
            border: none;
            padding: 18px 48px;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 30px;
            border-radius: 9999px;
            box-shadow: 0 10px 25px -5px rgba(22, 163, 74, 0.5);
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            /* Zorgt dat buttons goed reageren op touch */
            touch-action: manipulation; 
        }
        button:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 20px 30px -10px rgba(22, 163, 74, 0.7);
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 5px 15px -5px rgba(22, 163, 74, 0.4);
        }

        /* Scrollable Poem Box */
        .poem-scroll-container {
            background: rgba(15, 25, 15, 0.5);
            border: 1px solid rgba(234, 179, 8, 0.3);
            padding: 30px;
            margin-top: 20px;
            text-align: left;
            color: #fcd34d;
            width: 90%;
            max-width: 600px;
            max-height: 50vh;
            overflow-y: auto;
            font-size: 1.2rem;
            line-height: 1.7;
            border-radius: 24px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            white-space: pre-wrap;
            font-family: 'Rajdhani', sans-serif; 
            font-weight: 600;
            -webkit-overflow-scrolling: touch; /* Soepel scrollen op iPad */
        }
        
        .poem-scroll-container::-webkit-scrollbar {
            width: 8px;
        }
        .poem-scroll-container::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            margin: 10px 0;
            border-radius: 4px;
        }
        .poem-scroll-container::-webkit-scrollbar-thumb {
            background: #15803d;
            border-radius: 4px;
        }

        .hp-bar-bg {
            width: 100%; 
            height: 10px; 
            background: rgba(0,0,0,0.6); 
            border-radius: 99px; 
            overflow: hidden;
            margin-top: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .hp-bar-fill {
            height: 100%; 
            background: linear-gradient(90deg, #22c55e, #15803d); 
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
            border-radius: 99px;
        }
    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="flex justify-between w-full items-start">
            <!-- Dirk Stats -->
            <div class="hud-panel">
                <div class="hud-text">COMMANDANT DIRK</div>
                <div class="hp-bar-bg"><div id="dirk-hp" class="hp-bar-fill" style="width: 100%;"></div></div>
            </div>
            <!-- Enemy Stats -->
            <div class="hud-panel text-right">
                <div class="hud-text" style="color: #f87171;">VIJANDEN</div>
                <div class="sub-text" id="enemy-count">2 DOELWITTEN</div>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <div class="card">
            <h1 class="text-6xl text-green-400 font-bold mb-2 tracking-widest uppercase drop-shadow-lg">Artillery Dirk</h1>
            <h2 class="text-xl text-green-700 font-bold mb-8 uppercase tracking-widest">Worms Edition</h2>
            
            <div class="text-gray-300 mb-6 text-lg space-y-2">
                <p><span class="text-green-400 font-bold">SLEEP</span> om te richten</p>
                <p>Laat los om te <span class="text-green-400 font-bold">VUREN</span></p>
                <p>Vernietig tanks & landschap</p>
            </div>
            <p class="text-gray-500 text-sm italic font-mono bg-black/20 py-2 px-4 rounded-full inline-block">Reload tijd: 4 seconden</p>
            
            <div>
                <button id="btn-start">Start Missie</button>
            </div>
        </div>
    </div>

    <!-- Game Over -->
    <div id="game-over-screen">
        <div class="card">
            <h1 class="text-6xl text-red-500 font-bold mb-4 uppercase">Missie Mislukt</h1>
            <p class="text-gray-300 text-xl mb-6">Dirk heeft even rust nodig.</p>
            <button id="btn-restart" style="background: linear-gradient(135deg, #dc2626, #991b1b); box-shadow: 0 10px 25px -5px rgba(220, 38, 38, 0.5);">Hergroeperen</button>
        </div>
    </div>

    <!-- Victory -->
    <div id="victory-screen">
        <h1 class="text-5xl md:text-7xl text-green-400 font-bold mb-6 text-center uppercase drop-shadow-xl">Missie Volbracht</h1>
        
        <div class="poem-scroll-container">
Doelwit geraakt, missie volbracht.

Sint is jouw digitale verleden niet vergeten, 
Toen je uren achter Call of Duty hebt gezeten. 
Die training kwam goed van pas bij deze test, 
Zelfs als gamer ben je nog altijd op je best.

Het kruit is verschoten, de stilte keert weer,
Je legde zojuist nog de vijand neer.
Sint keek over je schouder mee naar het scherm,
En zag: jij bent nog altijd een tank-expert in de kern.

Het deed de Sint denken aan vervlogen tijden,
Toen je écht in zo’n stalen kolos mocht rijden.
Scherp op de korrel, de motor die ronkt,
In de jaren dat de jeugd nog in je ogen vonkt.
Toen zat er – en dat is geen flauwe lol –
Onder die helm nog een flinke krullenbol!

Die wilde haren ben je misschien wel kwijt,
Maar je bent nog lang niet verslagen door de tijd.
Want stilzitten, dat staat niet in jouw woordenboek,
Je bent altijd wel naar actie op zoek.
Even een balletje slaan op de tennisbaan,
Of fanatiek in je outfit hardlopen gaan.

En als je niet sport, ben je wel aan het bouwen,
Iemand aan wie we een hamer wel toe kunnen vertrouwen.
Die prachtige gangkast, door jou op maat gemaakt,
Is iets waar de Pieten-inpakdienst van smaakt.
Met zulke gouden handjes en technisch inzicht,
Is dit houten wapen wellicht aan jou verplicht.

Kijk maar eens goed naar het magazijn van dit geweer,
Die munitie doet geen pijn, maar smaakt wel naar meer.
Het is geen kruit om mee te knallen in de strijd,
Maar een sigaartje voor die spaarzame vrije tijd.

Toch is er nog een missie die jullie bezighoudt,
Een droom die je samen met je vrouw bouwt.
Weg uit Rhenen, of misschien toch daar blijven hangen?
Als het maar een plek is die jullie verlangen.
Een boerderijwoning, wat meer rust en ruimte om je heen,
In de Betuwe of op de Heuvelrug, met mooie steen.

Om die droom wat sneller dichterbij te halen,
Wil Sint niet enkel met pepernoten betalen.
Daarom krijg je munitie van een andere soort,
Waarmee je hopelijk flink wat budget scoort.
Een December Kalender en nog een extra lot,
Misschien zit er wel een fortuin in de pot!

En omdat je in het donker ook je rondjes blijft rennen,
Moeten we je niet alleen met gokken verwennen.
Veiligheid boven alles, dat leerde je al in het leger,
Dus wees in het donker geen onzichtbare veger.
Trek dit aan, dan zien ze je gaan,
Zodat je veilig weer voor de deur kunt staan.

Geniet van je munitie, je vest en de buit,
De missie is klaar, Sint gaat er tussenuit.
        </div>

        <button id="btn-victory">Nog een ronde</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null,
            init: function() {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!this.ctx) this.ctx = new AudioContext();
                    else if (this.ctx.state === 'suspended') this.ctx.resume();
                } catch(e) {}
            },
            playShoot: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(80, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.35);

                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.4, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.exponentialRampToValueAtTime(100, t + 0.2);
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start();
            },
            playExplosion: function() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 600; 
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.6, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }
        };

        // --- GAME CONSTANTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRAVITY = 0.2; 
        const EXPLOSION_RADIUS = 45;
        
        let width, height;
        let terrain = [];
        let clouds = [];

        let mouse = { x: 0, y: 0, down: false };
        
        let game = {
            active: false,
            projectiles: [],
            particles: [],
            enemies: [],
            dirk: null,
            lastTime: 0
        };

        const dirkQuotes = [
            "Als je krullen maar goed zitten!", 
            "Speciale levering: 100% loodvrij!", 
            "Wacht ff, mijn koffie wordt koud!", 
            "Boem! Recht in de roos (ongeveer)!",
            "Zeg maar dag tegen je laklaag!",
            "Krullenpower!",
            "Wie bestelde er schroot?",
            "Tijd voor een permanentje!",
            "Hoppa! Zo uit de heup!",
            "Pas op, ik heb mijn bril niet op!"
        ];
        
        const enemyQuotes = [
            "Zaten je krullen voor je ogen?", 
            "Dag krullenbol!", 
            "Jij gaat eraan!", 
            "Weg met dat permanent!", 
            "Krullen? Eerder prullen!",
            "Auw!", 
            "Ouwe!", 
            "Dekking!"
        ];

        // --- TERRAIN & ENVIRONMENT ---
        function generateTerrain() {
            terrain = new Float32Array(width);
            let baseHeight = height * 0.7;
            let noise1 = Math.random() * 0.02;
            let noise2 = Math.random() * 0.05;
            for(let x=0; x<width; x++) {
                terrain[x] = baseHeight 
                    + Math.sin(x * 0.005 + noise1) * 80 
                    + Math.sin(x * 0.015 + noise2) * 40;
            }
            clouds = [];
            for(let i=0; i<8; i++) {
                clouds.push({
                    x: Math.random() * width,
                    y: Math.random() * (height * 0.4),
                    w: 60 + Math.random() * 80,
                    speed: 0.1 + Math.random() * 0.2
                });
            }
        }

        function destroyTerrain(cx, cy, r) {
            const startX = Math.max(0, Math.floor(cx - r));
            const endX = Math.min(width, Math.ceil(cx + r));
            for(let x = startX; x < endX; x++) {
                let dx = x - cx;
                let dy = Math.sqrt(r*r - dx*dx);
                let circleBottom = cy + dy;
                if (terrain[x] < circleBottom) {
                    terrain[x] = circleBottom; 
                }
            }
        }

        // --- CLASSES ---
        class Tank {
            constructor(x, isPlayer) {
                this.x = x;
                this.y = terrain[Math.floor(x)];
                this.isPlayer = isPlayer;
                this.hp = isPlayer ? 101 : 50;
                this.maxHp = this.hp;
                this.angle = isPlayer ? -Math.PI/4 : -Math.PI*0.75;
                this.quote = null;
                this.quoteTimer = 0;
                this.canShoot = true;
                this.reloadTimer = 0;
                this.reloadDuration = isPlayer ? 4000 : 6000; 
            }

            update(dt) {
                if (this.hp <= 0) return;
                
                let groundY = terrain[Math.floor(this.x)];
                if (this.y < groundY) this.y += 2;
                else this.y = groundY;

                if (this.y > height - 15) {
                    this.y = height - 15;
                }

                if (!this.canShoot) {
                    this.reloadTimer += dt;
                    if (this.reloadTimer >= this.reloadDuration) {
                        this.canShoot = true;
                        this.reloadTimer = 0;
                    }
                }

                if (!this.isPlayer && game.active) {
                    if (this.canShoot && Math.random() < 0.01) {
                        this.shootAI();
                    }
                }

                if (this.quoteTimer > 0) this.quoteTimer -= dt;
            }

            shootAI() {
                let jitter = (Math.random() * 200) - 100; 
                let targetX = game.dirk.x + jitter;
                let targetY = game.dirk.y;
                let startX = this.x;
                let startY = this.y - 15;
                let dx = targetX - startX;
                let dy = targetY - startY; 
                let angle = -Math.PI/2 - 0.4 - (Math.random() * 0.2); 
                let g = GRAVITY;
                let term1 = dx * Math.tan(angle);
                let denominatorPart = dy - term1;
                let power = 0;
                if (denominatorPart > 0) {
                    let v2 = (g * dx * dx) / (2 * Math.pow(Math.cos(angle), 2) * denominatorPart);
                    power = Math.sqrt(v2);
                } else {
                    power = 15 + Math.random() * 5; 
                }
                power *= (0.9 + Math.random() * 0.2);
                power = Math.min(power, 25);

                game.projectiles.push(new Projectile(startX, startY, Math.cos(angle) * power, Math.sin(angle) * power, false));
                AudioEngine.playShoot();
                this.canShoot = false; 
                this.say(enemyQuotes[Math.floor(Math.random() * enemyQuotes.length)]);
            }

            say(text) {
                this.quote = text;
                this.quoteTimer = 5000; 
            }

            draw(ctx) {
                if (this.hp <= 0) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath(); ctx.ellipse(0, 0, 20, 5, 0, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = this.isPlayer ? '#4a6' : '#a55';
                ctx.beginPath(); ctx.roundRect(-15, -15, 30, 15, 3); ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); ctx.roundRect(-18, 0, 36, 6, 2); ctx.fill();
                ctx.fillStyle = '#333';
                for(let i=-12; i<=12; i+=8) {
                    ctx.beginPath(); ctx.arc(i, 3, 2, 0, Math.PI*2); ctx.fill();
                }

                ctx.save();
                ctx.translate(0, -15);
                let barrelAngle = this.angle;
                if(this.isPlayer) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - (this.y - 15);
                    barrelAngle = Math.atan2(dy, dx);
                    if(barrelAngle > 0) barrelAngle = 0; 
                    if(barrelAngle < -Math.PI) barrelAngle = -Math.PI;
                    this.angle = barrelAngle; 
                }
                ctx.rotate(barrelAngle);
                ctx.fillStyle = '#222';
                ctx.fillRect(0, -4, 26, 8);
                ctx.fillStyle = '#111'; 
                ctx.fillRect(24, -5, 4, 10);
                ctx.restore();

                if(this.isPlayer) {
                    ctx.fillStyle = '#f0c0a0';
                    ctx.beginPath(); ctx.arc(0, -20, 6, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#1f2f1f'; 
                    ctx.beginPath(); ctx.arc(0, -23, 6.5, Math.PI, 0); ctx.fill();
                    ctx.fillStyle = '#000'; 
                    ctx.fillRect(-3, -22, 6, 2);
                } else {
                    ctx.fillStyle = '#522';
                    ctx.beginPath(); ctx.arc(0, -15, 6, Math.PI, 0); ctx.fill();
                }

                ctx.fillStyle = '#333';
                ctx.fillRect(-20, -45, 40, 5);
                ctx.fillStyle = this.isPlayer ? '#22c55e' : '#ef4444';
                ctx.fillRect(-19, -44, 38 * (this.hp / this.maxHp), 3);

                if(this.isPlayer) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-20, -52, 40, 4);
                    ctx.fillStyle = this.canShoot ? '#38bdf8' : '#eab308';
                    let progress = this.canShoot ? 1 : (this.reloadTimer / this.reloadDuration);
                    ctx.fillRect(-19, -51, 38 * progress, 2);
                    if(!this.canShoot) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '8px Rajdhani';
                        ctx.textAlign = 'center';
                        ctx.fillText("HERLADEN...", 0, -55);
                    }
                }

                if(this.quoteTimer > 0 && this.quote) {
                    ctx.font = 'bold 18px Rajdhani';
                    ctx.textAlign = 'center';
                    let w = ctx.measureText(this.quote).width + 30; 
                    let bubbleH = 40;
                    ctx.save();
                    let shiftX = 0;
                    if (this.x - w/2 < 10) shiftX = 10 - (this.x - w/2);
                    else if (this.x + w/2 > width - 10) shiftX = (width - 10) - (this.x + w/2);
                    
                    ctx.translate(shiftX, -100); 
                    ctx.fillStyle = 'rgba(0,0,0,0.2)';
                    ctx.beginPath(); ctx.roundRect(-w/2 + 2, 2, w, bubbleH, 10); ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.roundRect(-w/2, 0, w, bubbleH, 10); ctx.fill(); ctx.stroke();
                    
                    ctx.beginPath(); 
                    ctx.moveTo(-5, bubbleH); 
                    ctx.lineTo(-shiftX, bubbleH + 10); 
                    ctx.lineTo(5, bubbleH); 
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.moveTo(-4, bubbleH); ctx.lineTo(4, bubbleH); ctx.lineTo(0, bubbleH + 1); ctx.fill();
                    ctx.fillStyle = this.isPlayer ? '#15803d' : '#991b1b';
                    ctx.fillText(this.quote, 0, 25); 
                    ctx.restore();
                }
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, vx, vy, isPlayer) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.isPlayer = isPlayer;
                this.radius = 4;
                this.active = true;
                this.trail = [];
            }

            update() {
                if(game.active && Math.random() > 0.5) {
                    this.trail.push({x: this.x, y: this.y});
                    if(this.trail.length > 15) this.trail.shift(); 
                }
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY;
                if(this.x < 0 || this.x > width) this.active = false;
                let groundY = terrain[Math.floor(this.x)] || height;
                if(this.y >= groundY) {
                    this.explode();
                    return;
                }
                let targets = this.isPlayer ? game.enemies : [game.dirk];
                targets.forEach(t => {
                    if(t.hp > 0 && Math.abs(this.x - t.x) < 25 && Math.abs(this.y - (t.y - 10)) < 25) {
                        t.hp -= 20;
                        this.explode();
                        if(t.isPlayer) document.getElementById('dirk-hp').style.width = (t.hp / 1.01) + '%';
                        if(t.hp <= 0 && !t.isPlayer) {
                            if(game.enemies.filter(e => e.hp > 0).length === 0) endGame(true);
                        } else if (t.hp <= 0 && t.isPlayer) {
                            endGame(false);
                        }
                    }
                });
            }

            explode() {
                this.active = false;
                destroyTerrain(this.x, this.y, EXPLOSION_RADIUS);
                AudioEngine.playExplosion();
                for(let i=0; i<20; i++) {
                    game.particles.push({
                        x: this.x, y: this.y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 2,
                        life: 1.0, 
                        color: this.isPlayer ? '#ffaa00' : '#ff4444',
                        size: Math.random() * 4 + 2
                    });
                }
            }

            draw(ctx) {
                if(this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = this.isPlayer ? 'rgba(255,255,255,0.3)' : 'rgba(255,0,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for(let t of this.trail) ctx.lineTo(t.x, t.y);
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.isPlayer ? '#fff' : '#300';
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if(terrain.length === 0) generateTerrain();
        }
        window.addEventListener('resize', resize);

        function initGame() {
            generateTerrain();
            game.projectiles = [];
            game.particles = [];
            game.dirk = new Tank(width * 0.15, true);
            document.getElementById('dirk-hp').style.width = '100%';
            game.enemies = [
                new Tank(width * 0.7, false),
                new Tank(width * 0.85, false)
            ];
            game.active = true;
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
            AudioEngine.init();
            game.lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function endGame(victory) {
            game.active = false;
            if(victory) document.getElementById('victory-screen').style.display = 'flex';
            else document.getElementById('game-over-screen').style.display = 'flex';
        }

        function drawEnvironment() {
            let grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#4aa3df'); 
            grad.addColorStop(1, '#87CEEB'); 
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);
            let sunGrad = ctx.createRadialGradient(width-80, 80, 10, width-80, 80, 60);
            sunGrad.addColorStop(0, '#ffffcc');
            sunGrad.addColorStop(1, 'rgba(255,255,200,0)');
            ctx.fillStyle = sunGrad;
            ctx.beginPath(); ctx.arc(width-80, 80, 60, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            clouds.forEach(c => {
                c.x += c.speed;
                if(c.x > width + 50) c.x = -100;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.w * 0.3, 0, Math.PI*2);
                ctx.arc(c.x + c.w * 0.2, c.y - c.w*0.1, c.w * 0.35, 0, Math.PI*2);
                ctx.arc(c.x + c.w * 0.5, c.y, c.w * 0.25, 0, Math.PI*2);
                ctx.fill();
            });
            let groundGrad = ctx.createLinearGradient(0, 0, 0, height);
            groundGrad.addColorStop(0, '#5d7e32'); 
            groundGrad.addColorStop(1, '#3b2912'); 
            ctx.fillStyle = groundGrad;
            ctx.beginPath();
            ctx.moveTo(0, height);
            for(let x=0; x<width; x++) {
                ctx.lineTo(x, terrain[x]);
            }
            ctx.lineTo(width, height);
            ctx.fill();
            ctx.strokeStyle = '#7ec850';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for(let x=0; x<width; x++) {
                if (x === 0) ctx.moveTo(x, terrain[x]);
                else ctx.lineTo(x, terrain[x]);
            }
            ctx.stroke();
        }

        function drawTrajectory() {
            if(!game.active || !game.dirk || !game.dirk.canShoot) return;
            let startX = game.dirk.x;
            let startY = game.dirk.y - 15;
            let dx = mouse.x - startX;
            let dy = mouse.y - startY;
            let angle = Math.atan2(dy, dx);
            let dist = Math.sqrt(dx*dx + dy*dy);
            let power = Math.min(dist * 0.15, 25);
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.setLineDash([4, 6]);
            ctx.lineWidth = 2;
            let simX = startX;
            let simY = startY;
            let simVx = Math.cos(angle) * power;
            let simVy = Math.sin(angle) * power;
            ctx.moveTo(simX, simY);
            for(let i=0; i<80; i++) { 
                simX += simVx;
                simY += simVy;
                simVy += GRAVITY;
                ctx.lineTo(simX, simY);
                if(simX < 0 || simX > width) break;
                if(terrain[Math.floor(simX)] && simY >= terrain[Math.floor(simX)]) break;
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function loop(timestamp) {
            if(!game.active) return;
            let dt = timestamp - game.lastTime;
            game.lastTime = timestamp;
            
            drawEnvironment();
            drawTrajectory();
            game.dirk.update(dt);
            game.dirk.draw(ctx);
            game.enemies.forEach(e => {
                e.update(dt);
                e.draw(ctx);
            });
            let aliveEnemies = game.enemies.filter(e => e.hp > 0).length;
            document.getElementById('enemy-count').innerText = aliveEnemies + " DOELWITTEN OVER";
            for(let i = game.projectiles.length-1; i>=0; i--) {
                let p = game.projectiles[i];
                p.update();
                p.draw(ctx);
                if(!p.active) game.projectiles.splice(i, 1);
            }
            for(let i = game.particles.length-1; i>=0; i--) {
                let p = game.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
                if(p.life <= 0) game.particles.splice(i, 1);
            }
            requestAnimationFrame(loop);
        }

        // --- UNIFIED INPUT HANDLING FOR DESKTOP & TOUCH ---
        function updateAim(x, y) {
            mouse.x = x;
            mouse.y = y;
        }

        function fire() {
            if(!game.active) return;
            if(!game.dirk.canShoot) return;
            
            let startX = game.dirk.x;
            let startY = game.dirk.y - 15;
            let dx = mouse.x - startX;
            let dy = mouse.y - startY;
            let angle = Math.atan2(dy, dx);
            let dist = Math.sqrt(dx*dx + dy*dy);
            let power = Math.min(dist * 0.15, 25);

            game.projectiles.push(new Projectile(startX, startY, Math.cos(angle)*power, Math.sin(angle)*power, true));
            AudioEngine.playShoot();

            game.dirk.canShoot = false; 
            game.dirk.say(dirkQuotes[Math.floor(Math.random() * dirkQuotes.length)]);
        }

        // Mouse Events
        document.addEventListener('mousemove', e => updateAim(e.clientX, e.clientY));
        document.addEventListener('mousedown', (e) => {
            if(e.target.tagName !== 'BUTTON') {
                // Alleen vuren op mouse down (click)
                updateAim(e.clientX, e.clientY);
                fire();
            }
        });

        // Touch Events (iPad Support)
        document.addEventListener('touchstart', e => {
            if(e.target.tagName !== 'BUTTON') {
                e.preventDefault(); // Voorkom scrollen
                updateAim(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        document.addEventListener('touchmove', e => {
            if(e.target.tagName !== 'BUTTON') {
                e.preventDefault();
                updateAim(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        document.addEventListener('touchend', e => {
            if(e.target.tagName !== 'BUTTON') {
                fire(); // Vuur als vinger wordt opgetild
            }
        });

        document.getElementById('btn-start').addEventListener('click', initGame);
        document.getElementById('btn-restart').addEventListener('click', initGame);
        document.getElementById('btn-victory').addEventListener('click', initGame);

        resize();

    </script>
</body>
</html>